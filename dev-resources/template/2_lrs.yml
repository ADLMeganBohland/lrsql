AWSTemplateFormatVersion: "2010-09-09"
Description: "SQL LRS and DB Init Script"
Parameters:
  # Networking
  VPCStackName:
    Description: Name of VPC Stack
    Type: String
  VPCId:
    Description: "VPC on which to run SQL LRS (if not provided, will attempt to use parameter VPC on VPCStackName)"
    Type: AWS::EC2::VPC::Id
  DBSubnets:
    Description: Subnets on which the DB is running (if not provided, will use PrivateSubnetOne and PrivateSubnetTwo on VPCStackName)
    Type: List<AWS::EC2::Subnet::Id>
  # DB Details
  DBStackName:
    Description: DB Stack Reference
    Type: String
    Default: yetadmin
  DBAppUserName:
    Description: Name of app db user
    Type: String
    Default: lrsqldbuser
  DBMasterUserPasswordPath:
    Description: SSM Path to the secret password
    Type: String
    Default: "/lrsql/demo/DB_MASTER_USER_PASSWORD"
  DBMasterUserPasswordVersion:
    Description: SSM version
    Type: Number
    Default: 1
  DBAppUserPasswordPath:
    Description: SSM Path to the secret password
    Type: String
    Default: "/lrsql/demo/DB_APP_USER_PASSWORD"
  DBAppUserPasswordVersion:
    Description: SSM version
    Type: Number
    Default: 1
  # Lambda Script
  S3Bucket:
    Type: String
    Default: lrsql-demo
  S3Key:
    Type: String
    Default: db-init.zip

  # Server(s)
  InstanceType:
    Type: String
    Description: EC2 Instance Type to launch.
    Default: c5.large
    AllowedValues:
      - c5.large
      - c5.xlarge
      - c5.2xlarge
      - c5.4xlarge
  InstanceAmiId:
    Description: AMI (image) to use on EC2 instances.
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: "/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2"
  InstanceKeyName:
    Description: Name of an EC2 key pair that can be used to connect to the server (optional)
    Type: String
  InstanceSSHCidr:
    Description: CIDR Range for SSH Access to instances (Typically VPC CIDR Range)
    Type: String
    Default: "172.147.0.0/16"
  InstanceHttpPort:
    Description: Port on which the server runs HTTP
    Type: String
    Default: 8080
  DefaultAdminUser:
    Description: Username of seed lrs admin
    Type: String
    Default: lrsqladmin
  DefaultAdminPass:
    Description: Initial seed password for lrs admin
    Type: String
  LrsVersion:
    Description: Version of SQL LRS to download and install (public release versions on GitHub)
    Type: String
    Default: v0.5.1

  ASGMinSize:
    Type: Number
    Default: 1
    Description: Minimum number of instances to launch in the autoscaling group.
  ASGDesiredSize:
    Type: Number
    Description: Desired number of instances to launch in the autoscaling group.
    Default: 1
  ASGMaxSize:
    Type: Number
    Description: Maximum number of instances to launch in the autoscaling group.
    Default: 2
  ASGCPUPolicyTargetValue:
    Type: String # according to docs a Double
    Description: Target CPU utilization of instances. Leave blank to disable CPU autoscaling.
    Default: "" # "60.0"
  ASGALBRequestCountTargetValue:
    Type: String # according to docs a Double
    Description: Target requests per instance. Leave blank to disable request count autoscaling.
    Default: "" # "10000.0"

  # Front-end (ALB) specific settings
  ALBHostName:
    Type: String
    Description: The hostname to use for the Elastic Load Balancer.
    Default: "sqllrs.yetanalytics.io"
  ALBCertArn:
    Type: String
    Description: The ARN of an ACM cert to use on the ALB
  ALBHostedZone:
    Type: String
    Description: Route53 Hosted Zone in which to set a DNS record. If unset no record will be updated
    Default: ""
  # CORS Settings
  CORSAllowedOrigins:
    Type: CommaDelimitedList
    Description: A comma-separated list of origins to allow. If not provided ALBHostName will be used if present, otherwise no origins will be allowed.


Conditions:
  SetDNS:
    !Not [!Equals [!Ref ALBHostedZone, ""]]
  SetCORS:
    !Not [!Equals [!Join ["", !Ref CORSAllowedOrigins], ""]]
  ASGCPUPolicyTargetValueProvided:
    !Not [!Equals [!Ref ASGCPUPolicyTargetValue, ""]]
  ASGALBRequestCountTargetValueProvided:
    !Not [!Equals [!Ref ASGALBRequestCountTargetValue, ""]]
  InstanceKeyNameProvided:
    !Not [!Equals [!Ref InstanceKeyName, ""]]
  VPCIdProvided:
    !Not [!Equals [!Ref VPCId, ""]]
  DBSubnetsProvided:
    !Not [!Equals [!Ref DBSubnets, !Ref "AWS::NoValue"]]

Resources:

  # DB Initialization Function and custom resource to run it

  DBInitFn:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        S3Bucket: !Ref S3Bucket
        S3Key: !Ref S3Key
      Handler: index.handler
      Runtime: nodejs14.x
      Timeout: 15
      Role: !GetAtt DBInitFnExecRole.Arn
      VpcConfig:
        SecurityGroupIds:
          - !Ref DBInitFnSG
        SubnetIds: !If
          - DBSubnetsProvided
          - !Ref DBSubnets
          - - Fn::ImportValue: !Join [":", [!Ref "VPCStackName", "PrivateSubnetOne"]]
            - Fn::ImportValue: !Join [":", [!Ref "VPCStackName", "PrivateSubnetTwo"]]
  DBInitFnSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: SG For Lambda Init Fn
      VpcId: !If
        - VPCIdProvided
        - !Ref VPCId
        - Fn::ImportValue: !Join [":", [!Ref "VPCStackName", "VPC"]]

  DBInstanceInitIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Ingress from the init fn to RDS instance
      GroupId:
        Fn::ImportValue: !Join [":", [!Ref "DBStackName", "DBInstanceSG"]]
      IpProtocol: tcp
      FromPort:
        Fn::ImportValue:
          !Join [":", [!Ref "DBStackName", "DBPort"]]
      ToPort:
        Fn::ImportValue:
          !Join [":", [!Ref "DBStackName", "DBPort"]]
      SourceSecurityGroupId: !Ref DBInitFnSG

  DBInitPolicy:
    Type: AWS::IAM::ManagedPolicy
    Description: IAM Policy for db init lambda access.
    Properties:
      ManagedPolicyName: !Sub "${AWS::StackName}-${AWS::Region}-lambda-dbinit-policy"
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          # Allow access to SSM and VPC related networking
          - Effect: Allow
            Action:
              - "ssm:GetParameter"
              - "secretsmanager:GetSecretValue"
            Resource:
              - !Sub "arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter${DBAppUserPasswordPath}"
              - !Sub "arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter${DBMasterUserPasswordPath}"
          - Effect: Allow
            Action:
              - ec2:DescribeNetworkInterfaces
              - ec2:CreateNetworkInterface
              - ec2:DeleteNetworkInterface
              - ec2:DescribeInstances
              - ec2:AttachNetworkInterface
            Resource: "*"

  DBInitFnExecRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: [lambda.amazonaws.com]
            Action: ["sts:AssumeRole"]
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess
        - !Ref DBInitPolicy

  InitDBCustomResource:
    # Run the lambda init fn as a custom resource
    Type: Custom::initDBCustomResource
    DependsOn: DBInitFn
    Properties:
      ServiceToken: !GetAtt DBInitFn.Arn
      DBMasterUsername:
        Fn::ImportValue: !Join [":", [!Ref "DBStackName", "DBMasterUserName"]]
      DBMasterPasswordPath: !Join
        - ":"
        - - !Ref DBMasterUserPasswordPath
          - !Ref DBMasterUserPasswordVersion
      DBUsername: !Ref DBAppUserName
      DBPasswordPath: !Join
        - ":"
        - - !Ref DBAppUserPasswordPath
          - !Ref DBAppUserPasswordVersion
      DBHost:
        Fn::ImportValue:
          !Join [":", [!Ref "DBStackName", "DBEndpoint"]]
      DBPort:
        Fn::ImportValue:
          !Join [":", [!Ref "DBStackName", "DBPort"]]
      DBName:
        Fn::ImportValue:
          !Join [":", [!Ref "DBStackName", "DBName"]]

  # Servers

  InstancePolicy:
    Type: AWS::IAM::ManagedPolicy
    Description: IAM Policy for a SQL LRS Server.
    Properties:
      ManagedPolicyName: !Sub "${AWS::StackName}-${AWS::Region}-lrsql-instance-policy"
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          # Allow pulling DB password
          - Effect: Allow
            Action:
              - "ssm:GetParameter"
              - "secretsmanager:GetSecretValue"
            Resource:
              - !Sub "arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter${DBAppUserPasswordPath}"
          # Allegedly needed for securestring...
          - Effect: Allow
            Action:
              - "kms:Decrypt"
            Resource:
              - !Sub "arn:aws:kms:${AWS::Region}:${AWS::AccountId}:alias/aws/secretsmanager"
              - !Sub "arn:aws:kms:${AWS::Region}:${AWS::AccountId}:alias/aws/ssm"

  InstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [ec2.amazonaws.com]
          Action: ["sts:AssumeRole"]
      Path: /
      ManagedPolicyArns:
        - !Ref InstancePolicy

  InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles: [!Ref InstanceRole]

  InstanceSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Access to the LRS Instance
      VpcId: !If
        - VPCIdProvided
        - !Ref VPCId
        - Fn::ImportValue: !Join [":", [!Ref "VPCStackName", "VPC"]]
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: !Ref InstanceSSHCidr

  DBInstanceIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Ingress from the LRS instance to RDS instance
      GroupId:
        Fn::ImportValue: !Join [":", [!Ref "DBStackName", "DBInstanceSG"]]
      IpProtocol: tcp
      FromPort:
        Fn::ImportValue:
          !Join [":", [!Ref "DBStackName", "DBPort"]]
      ToPort:
        Fn::ImportValue:
          !Join [":", [!Ref "DBStackName", "DBPort"]]
      SourceSecurityGroupId: !Ref InstanceSG

  LrsInstances:
    Type: AWS::AutoScaling::LaunchConfiguration
    DependsOn: InitDBCustomResource
    CreationPolicy:
      ResourceSignal:
        Timeout: PT15M
    Metadata:
      AWS::CloudFormation::Init:
        configSets:
          default:
            - 00_installLrs
            - 01_setupCfnHup
            - 02_configureLrs
            - 03_enableLrs
            - 04_startLrs
          UpdateEnvironment:
            - 00_installLrs
            - 02_configureLrs
            - 05_restartLrs
        00_installLrs:
          files:
            "/tmp/lrsql.zip":
              source: !Join
                - "/"
                - - "https://github.com/yetanalytics/lrsql/releases/download"
                  - !Ref LrsVersion
                  - "lrsql.zip"
              mode: "000755"
              owner: "root"
              group: "root"
          commands:
            00make_dir:
              cwd: "~"
              command: "sudo mkdir /opt/lrsql"
            01unzip_lrs:
              cwd: "~"
              command: "sudo unzip /tmp/lrsql.zip -d /opt/lrsql/"
        01_setupCfnHup:
          files:
            "/etc/cfn/cfn-hup.conf":
              content: !Sub |
                [main]
                stack=${AWS::StackId}
                region=${AWS::Region}
                interval=1
              mode: "000400"
              owner: root
              group: root
            "/lib/systemd/system/cfn-hup.service":
              content: !Sub |
                [Unit]
                Description=cfn-hup daemon
                [Service]
                Type=simple
                ExecStart=/opt/aws/bin/cfn-hup
                Restart=always
                [Install]
                WantedBy=multi-user.target
            "/etc/cfn/hooks.d/lrsql-auto-reloader.conf":
              content: !Sub |
                [cfn-auto-reloader-hook]
                triggers=post.update
                path=Resources.LrsInstances.Metadata.AWS::CloudFormation::Init.02_configureLrs
                action=/opt/aws/bin/cfn-init -v --stack ${AWS::StackId} --resource LrsInstances --region ${AWS::Region} --configsets UpdateEnvironment
                runas=root
              mode: "000400"
              owner: root
              group: root
          commands:
            01enable_cfn_hup:
              command: !Sub |
                systemctl enable cfn-hup.service
            02start_cfn_hup:
              command: !Sub |
                systemctl start cfn-hup.service
        02_configureLrs:
          files:
            "/opt/lrsql/config/lrsql.json":
              content: !Sub
                -  |
                   {
                      "database": {
                      "dbHost": "${DBHost}",
                      "dbPort": ${DBPort},
                      "dbName": "${DBName}",
                      "dbUser": "${DBAppUserName}",
                      "dbPassword": "${DBPass}"
                    },
                    "lrs" : {
                      "adminUserDefault": "${DefaultAdminUser}",
                      "adminPassDefault": "${DefaultAdminPass}",
                      "authorityUrl": "http://mydomain.com"
                    },
                    "webserver": {
                      "httpHost": "0.0.0.0",
                      "httpPort": ${InstanceHttpPort}
                      "allowedOrigins": ${AllowedOrigins}
                    }
                  }
                - DBName:
                    Fn::ImportValue: !Join [":", [!Ref "DBStackName", "DBName"]]
                  DBHost:
                    Fn::ImportValue: !Join [":", [!Ref "DBStackName", "DBEndpoint"]]
                  DBAppUserName: !Ref DBAppUserName
                  DBPass: !GetAtt InitDBCustomResource.dbAppPass
                  DefaultAdminUser: !Ref DefaultAdminUser
                  DefaultAdminPass: !Ref DefaultAdminPass
                  InstanceHttpPort: !Ref InstanceHttpPort
                  DBPort:
                    Fn::ImportValue: !Join [":", [!Ref "DBStackName", "DBPort"]]
                  AllowedOrigins: !If
                    - SetCORS
                    - !Sub
                      - '["${JoinedAllowedOrigins}}"]'
                    - !If
                      - SetDNS
                      - !Sub '["https://${ALBHostName}"]'
                      - "[]"
              mode: "000755"
              owner: root
              group: root
            "/lib/systemd/system/lrsql.service":
              content: !Sub |
                [Unit]
                Description=SQL LRS Service
                [Service]
                User=root
                # Required to prevent arbitrary encoding settings
                Environment="LC_ALL=en_US.UTF-8"
                # The configuration file application.properties should be here:
                WorkingDirectory=/opt/lrsql
                ExecStart=/opt/lrsql/bin/run_postgres.sh
                SuccessExitStatus=143
                TimeoutStopSec=10
                Restart=on-failure
                RestartSec=5
                [Install]
                WantedBy=multi-user.target
              mode: "000755"
              owner: root
              group: root
        03_enableLrs:
          commands:
            01enable_lrsql:
              command: !Sub |
                systemctl enable lrsql.service
        04_startLrs:
          commands:
            01start_lrsql:
              command: !Sub |
                systemctl start lrsql.service
        05_restartLrs:
          commands:
            01daemon_reload:
              command: |
                systemctl daemon-reload
            02restart_lrsql:
              command: !Sub |
                systemctl restart lrsql.service
    Properties:
      ImageId: !Ref InstanceAmiId
      InstanceType: !Ref InstanceType
      KeyName: !If
        - InstanceKeyNameProvided
        - !Ref InstanceKeyName
        - !Ref AWS::NoValue
      SecurityGroups:
        - !Ref InstanceSG
      IamInstanceProfile: !Ref InstanceProfile
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash -xe
          echo 'Yet SQL LRS ${LrsVersion}'
          # run configsets
          /opt/aws/bin/cfn-init -v --stack ${AWS::StackId} --resource LrsInstances --region ${AWS::Region} --configsets default
          # signal CF
          /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackId} --resource AutoScalingGroup --region ${AWS::Region}

  # Autoscaling Policies

  # Average CPU utilization of instances
  ASGCPUPolicy:
    Type: AWS::AutoScaling::ScalingPolicy
    Condition: ASGCPUPolicyTargetValueProvided
    Properties:
      AutoScalingGroupName: !Ref AutoScalingGroup
      PolicyType: TargetTrackingScaling
      TargetTrackingConfiguration:
        PredefinedMetricSpecification:
          PredefinedMetricType: ASGAverageCPUUtilization
        TargetValue: !Ref ASGCPUPolicyTargetValue

  # Requests inbound to the ALB Target
  ASGALBRequestCountPolicy:
    Type: AWS::AutoScaling::ScalingPolicy
    Condition: ASGALBRequestCountTargetValueProvided
    Properties:
      AutoScalingGroupName: !Ref AutoScalingGroup
      PolicyType: TargetTrackingScaling
      TargetTrackingConfiguration:
        PredefinedMetricSpecification:
          PredefinedMetricType: ALBRequestCountPerTarget
          ResourceLabel: !Join
            - "/"
            - - !GetAtt LoadBalancer.LoadBalancerFullName
              - !GetAtt TargetGroup.TargetGroupFullName
        TargetValue: !Ref ASGALBRequestCountTargetValue


  # ASG
  AutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      VPCZoneIdentifier: !If
        - DBSubnetsProvided
        - !Ref DBSubnets
        - - Fn::ImportValue: !Join [":", [!Ref "VPCStackName", "PublicSubnetOne"]]
          - Fn::ImportValue: !Join [":", [!Ref "VPCStackName", "PublicSubnetTwo"]]
      LaunchConfigurationName: !Ref LrsInstances
      MinSize: !Ref ASGMinSize
      MaxSize: !Ref ASGMaxSize
      DesiredCapacity: !Ref ASGDesiredSize
      # Attach to Target Group for ALB
      TargetGroupARNs:
        - !Ref TargetGroup
      HealthCheckType: ELB
      HealthCheckGracePeriod: 120
      # Enable Group Metrics Collection
      MetricsCollection:
        - Granularity: "1Minute"
    CreationPolicy:
      ResourceSignal:
        Timeout: PT15M
    UpdatePolicy:
      AutoScalingRollingUpdate:
        MinInstancesInService: "1"
        MaxBatchSize: "1"
        PauseTime: PT15M
        WaitOnResourceSignals: "true"
        SuspendProcesses:
          - HealthCheck
          - ReplaceUnhealthy
          - AZRebalance
          - AlarmNotification
          - ScheduledActions


  # Load Balancer

  LoadBalancerSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Access to the load balancer
      VpcId: !If
        - VPCIdProvided
        - !Ref VPCId
        - Fn::ImportValue: !Join [":", [!Ref "VPCStackName", "VPC"]]
      SecurityGroupIngress:
        # Allow access to ALB from anywhere on the internet
        # on 80 as redirect-only
        - CidrIp: 0.0.0.0/0
          IpProtocol: tcp
          FromPort: 80
          ToPort: 80
        # on http:443 for https
        - CidrIp: 0.0.0.0/0
          IpProtocol: tcp
          FromPort: 443
          ToPort: 443

  LoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Scheme: internet-facing
      LoadBalancerAttributes:
        - Key: idle_timeout.timeout_seconds
          Value: "30"
      Subnets: !If
        - DBSubnetsProvided
        - !Ref DBSubnets
        - - Fn::ImportValue: !Join [":", [!Ref "VPCStackName", "PublicSubnetOne"]]
          - Fn::ImportValue: !Join [":", [!Ref "VPCStackName", "PublicSubnetTwo"]]
      SecurityGroups:
        - !Ref LoadBalancerSG

  LoadBalancerListenerHTTP:
    #redirect to https
    Type: AWS::ElasticLoadBalancingV2::Listener
    DependsOn:
      - LoadBalancer
    Properties:
      DefaultActions:
        - RedirectConfig:
            Protocol: HTTPS
            StatusCode: HTTP_301
            Port: "443"
            Host: "#{host}"
            Path: "/#{path}"
            Query: "{query}"
          Type: "redirect"
      LoadBalancerArn: !Ref LoadBalancer
      Port: 80
      Protocol: HTTP

  LoadBalancerListenerHTTPS:
    Type: AWS::ElasticLoadBalancingV2::Listener
    DependsOn:
      - LoadBalancer
    Properties:
      DefaultActions:
        - TargetGroupArn: !Ref TargetGroup
          Type: "forward"
      LoadBalancerArn: !Ref LoadBalancer
      Port: 443
      Protocol: HTTPS
      Certificates:
        - CertificateArn: !Ref ALBCertArn

  IngressFromALB:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Ingress from the ALB
      GroupId: !Ref InstanceSG
      IpProtocol: tcp
      FromPort: !Ref InstanceHttpPort
      ToPort: !Ref InstanceHttpPort
      SourceSecurityGroupId: !Ref LoadBalancerSG

  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 30
      HealthCheckPath: /health
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 2
      Port: !Ref InstanceHttpPort
      Protocol: HTTP
      UnhealthyThresholdCount: 2
      VpcId: !If
        - VPCIdProvided
        - !Ref VPCId
        - Fn::ImportValue: !Join [":", [!Ref "VPCStackName", "VPC"]]

  #DNS Update for Domain

  DNSRecordSet:
    Condition: SetDNS
    Type: AWS::Route53::RecordSet
    Properties:
      Type: A
      Name: !Ref ALBHostName
      HostedZoneId: !Ref ALBHostedZone
      # Set the target, depending if we are on APIGW or EC2
      AliasTarget:
        DNSName: !GetAtt LoadBalancer.DNSName
        HostedZoneId: !GetAtt LoadBalancer.CanonicalHostedZoneID

Outputs:
  LBEndpoint:
    Description: Load Balancer Endpoint
    Value: !GetAtt LoadBalancer.DNSName
    Export:
      Name: !Sub "${AWS::StackName}:LBEndpoint"
  LrsAddress:
    Description: Location of the LRS and Admin application
    Value: !Join
      - ""
      - - "https://"
        - !Ref ALBHostName
    Export:
      Name: !Sub "${AWS::StackName}:LrsAddress"
